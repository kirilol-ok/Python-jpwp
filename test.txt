1. Jaką rolę pełni blok else w konstrukcji try/except/else/finally?
A. Pozwala wykonać kod tylko wtedy, gdy wyjątek wystąpił.
B. Umożliwia zdefiniowanie kodu, który wykona się zawsze, niezależnie od wyjątków.
C. Uruchamia się tylko wtedy, gdy w bloku try nie wystąpił żaden wyjątek.
D. Służy do obsługi wyjątków typu ValueError i TypeError.

Odp: C

2. Co zrobi menedżer kontekstu FileTransaction w przypadku wyjątku występującego wewnątrz bloku with?
A. Usunie wszystkie pliki w katalogu roboczym.
B. Przywróci oryginalną zawartość pliku z kopii zapasowej.
C. Zignoruje błąd i zostawi plik w stanie częściowego zapisu.
D. Zawsze nadpisze plik pustą zawartością.

Odp: D

3. Kiedy w projekcie lepiej użyć warnings.warn() zamiast raise?
A. Gdy chcemy przerywać działanie programu natychmiast.
B. Jeśli chcemy jedynie poinformować o niekrytycznym problemie i kontynuować wykonywanie.
C. Kiedy potrzebujemy wyświetlić pełny stack trace w konsoli.
D. W sytuacji, gdy moduł logging nie jest dostępny.

Odp: D

4. Jaki jest główny cel użycia pdb.set_trace() w kodzie?
A. Zapisanie logów debugujących do pliku.
B. Przeprowadzenie interaktywnej sesji debuggera w miejscu zatrzymania programu.
C. Automatyczne ponowne uruchomienie programu po błędzie.
D. Wyciszenie wszystkich wyjątków w aplikacji.

Odp: D

5. Które polecenie w pdb pozwala przejść do następnej linii kodu, nie wchodząc do funkcji?
A. s
B. c
C. p
D. n

Odp: B


